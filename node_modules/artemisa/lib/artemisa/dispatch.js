'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.storagePropertyNameForAction = exports.actionName = exports.isArtemisaAction = exports.isArtemisaReceive = exports.isArtemisaType = exports.ARTEMISA = undefined;
exports.dispatchFetches = dispatchFetches;
exports.shouldFetch = shouldFetch;

var _actions = require('../core/actions');

var _model = require('../core/model');

var ARTEMISA = exports.ARTEMISA = 'ARTEMISA';
var isArtemisaType = exports.isArtemisaType = function isArtemisaType(type) {
  return type && !!type.match(/^ARTEMISA/);
};
var isArtemisaReceive = exports.isArtemisaReceive = function isArtemisaReceive(action) {
  return (0, _actions.isReceive)(action) && isArtemisaType(action.originType);
};
var isArtemisaAction = exports.isArtemisaAction = function isArtemisaAction(action) {
  return isArtemisaType(action.type);
};

var actionName = exports.actionName = function actionName(storeFieldName) {
  return ARTEMISA + '_' + storeFieldName;
};

var storagePropertyNameForAction = exports.storagePropertyNameForAction = function storagePropertyNameForAction(action) {
  return action.originType.slice(ARTEMISA.length + 1);
};

function dispatchFetches(props, state, dispatch, fetches) {
  fetches.forEach(function (fetch) {
    dispatchFetch(props, state, dispatch, fetch);
  });
}

function dispatchFetch(props, state, dispatch, _ref) {
  var storeFieldName = _ref.storeFieldName,
      call = _ref.call,
      on = _ref.on;

  if (!on(props, state)) {
    return;
  }
  var action = {
    type: actionName(storeFieldName),
    dataApiCall: call(props, state)
  };
  var should = shouldFetch(state.artemisa[storeFieldName], action.dataApiCall.path, function (s) {
    return s.path;
  });
  if (should) {
    dispatch(action);
  }
}

/**
 * If we have a piece state managed by this framework, and the value has a transformerId,
 * this function tells if it is necessary to do a new fetch.
 */
function shouldFetch(fetchState, key, keyProvider) {

  // No key => no fetch
  if (!key) return false;

  // fecthState is not even initialized, do a first fetch
  if (!fetchState) return true;

  // We are already fetching
  if ((0, _model.isFetchingSlot)(fetchState) && (!keyProvider || keyProvider(fetchState) === key)) return false;

  // Handle errors
  if ((0, _model.isErrorSlot)(fetchState) && (!keyProvider || keyProvider(fetchState) === key)) {
    /* eslint-disable no-console */
    console.log('Ignoring request to fetch \'' + key + '\' because of previous error: \'' + fetchState.error + '\'');
    return false;
  }

  return (keyProvider || function (s) {
    return s.value.transformerId;
  })(fetchState) !== key;
}