'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFetched = exports.isFetching = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.artemisa = artemisa;
exports.processApiAction = processApiAction;

var _dispatch = require('./dispatch');

var _actions = require('../core/actions');

var _model = require('../core/model');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
// TODO: 
//  - implement a cache timeout (store fetched date, and refetch after some time)
//  - implement an LRU to cache not only the last value but a couple of them for each URL

function artemisa() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments[1];

  if (action.originType && (0, _dispatch.isArtemisaAction)(action)) {
    return processApiAction((0, _dispatch.storagePropertyNameForAction)(action), state, action);
  }
  return state;
}

function processApiAction(stateProperty, state, action) {
  if ((0, _actions.isRequest)(action)) {
    return _extends({}, state, _defineProperty({}, stateProperty, {
      state: _model.State.FETCHING,
      path: action.path
    }));
  }
  if ((0, _actions.isReceive)(action)) {
    var myState = state[stateProperty],
        restOfState = _objectWithoutProperties(state, [stateProperty]);

    return !myState || myState.path === action.path ? _extends({}, restOfState, _defineProperty({}, stateProperty, {
      state: _model.State.FETCHED,
      path: action.path,
      value: action.data
    }))
    // Received action does not correspond to the path in FETCHING state,
    // we asume that the data received corresponds to an old request is old and discard it.
    : state;
  }
  if ((0, _actions.isError)(action)) {
    return _extends({}, state, _defineProperty({}, stateProperty, {
      state: _model.State.ERROR,
      path: action.path,
      error: action.error
    }));
  }
  throw new Error('Unknown API action', action);
}

// checking state (should be moved to another file ?)
var isFetching = exports.isFetching = function isFetching(state, stateProperty) {
  return (0, _model.isFetchingSlot)(state[stateProperty]);
};
var isFetched = exports.isFetched = function isFetched(state, stateProperty) {
  return (0, _model.isFetchedSlot)(state[stateProperty]);
};